<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ls on PatoJAD | Pasion por la Tecnologia</title><link>https://patojad.com.ar/tags/ls/</link><description>Recent content in Ls on PatoJAD | Pasion por la Tecnologia</description><generator>Hugo -- gohugo.io</generator><language>es-AR</language><lastBuildDate>Tue, 03 Feb 2026 08:31:00 +0000</lastBuildDate><atom:link href="https://patojad.com.ar/tags/ls/index.xml" rel="self" type="application/rss+xml"/><item><title>Terminal Pro 2026: Deja de usar comandos de los años 70</title><link>https://patojad.com.ar/post/2026/02/terminal-pro-2026-deja-de-usar-comandos-de-los-a%C3%B1os-70/</link><pubDate>Tue, 03 Feb 2026 08:31:00 +0000</pubDate><guid>https://patojad.com.ar/post/2026/02/terminal-pro-2026-deja-de-usar-comandos-de-los-a%C3%B1os-70/</guid><description>&lt;p&gt;Linux es famoso por su estabilidad, pero eso no significa que debas seguir usando las mismas herramientas que se inventaron cuando no existía internet. En 2026, hay una nueva generación de herramientas escritas en Rust y Go que son más rápidas, tienen mejores colores y, sobre todo, te hacen más productivo.&lt;/p&gt;
&lt;p&gt;Aquí tienes los reemplazos directos que todo dev debería instalar hoy mismo:&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="1-eza-el-reemplazo-de-ls"&gt;
1. &lt;code&gt;eza&lt;/code&gt; (El reemplazo de &lt;code&gt;ls&lt;/code&gt;)
&lt;a href="#1-eza-el-reemplazo-de-ls" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;¿Sigues usando &lt;code&gt;ls -la&lt;/code&gt;? &lt;code&gt;eza&lt;/code&gt; (el sucesor de &lt;code&gt;exa&lt;/code&gt;) te da colores por tipo de archivo, iconos, integración con Git y una vista de árbol integrada.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;eza --long --header --git --icons
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="2-bat-el-reemplazo-de-cat"&gt;
2. &lt;code&gt;bat&lt;/code&gt; (El reemplazo de &lt;code&gt;cat&lt;/code&gt;)
&lt;a href="#2-bat-el-reemplazo-de-cat" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; es genial para ver un archivo rápido, pero no tiene resaltado de sintaxis. &lt;code&gt;bat&lt;/code&gt; es un clon de &lt;code&gt;cat&lt;/code&gt; con esteroides: añade numeración de líneas, integración con Git (muestra qué líneas cambiaste) y syntax highlighting para casi cualquier lenguaje de programación.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;bat archivo.ts
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="3-fd-el-reemplazo-de-find"&gt;
3. &lt;code&gt;fd&lt;/code&gt; (El reemplazo de &lt;code&gt;find&lt;/code&gt;)
&lt;a href="#3-fd-el-reemplazo-de-find" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;find&lt;/code&gt; tiene una sintaxis horrible que nadie recuerda. &lt;code&gt;fd&lt;/code&gt; es 10 veces más rápido y su sintaxis es intuitiva. Además, ignora por defecto las carpetas .git y node_modules. ¡Oro puro!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;fd &lt;span class="s2"&gt;&amp;#34;patron_de_busqueda&amp;#34;&lt;/span&gt; ./ruta/de/busqueda
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="4-fzf-el-buscador-borroso"&gt;
4. &lt;code&gt;fzf&lt;/code&gt; (El buscador borroso)
&lt;a href="#4-fzf-el-buscador-borroso" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Si no usas &lt;code&gt;fzf&lt;/code&gt;, estás perdiendo el tiempo. Te permite buscar entre tus archivos o tu historial de comandos de forma interactiva mientras escribes. Es, probablemente, la herramienta que más te va a cambiar la vida en la terminal.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;history&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; fzf
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="4-btop-el-reemplazo-de-top"&gt;
4. &lt;code&gt;btop&lt;/code&gt; (El reemplazo de &lt;code&gt;top&lt;/code&gt;)
&lt;a href="#4-btop-el-reemplazo-de-top" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;top&lt;/code&gt; es funcional, pero feo y difícil de usar. &lt;code&gt;btop&lt;/code&gt; tiene una interfaz mucho más amigable, con colores, barras de uso de CPU/RAM y la capacidad de matar procesos con solo presionar una tecla.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;btop
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>Una visita guiada</title><link>https://patojad.com.ar/post/2020/08/una-visita-guiada/</link><pubDate>Fri, 28 Aug 2020 09:15:00 +0000</pubDate><guid>https://patojad.com.ar/post/2020/08/una-visita-guiada/</guid><description>&lt;p&gt;La disposición del sistema de archivos en tu sistema Linux es casi como el que encontramos en otros sistemas tipo Unix. El diseño está especificado en un estándar publicado llamado &lt;strong&gt;Linux Filesystem Hierarchy Standard&lt;/strong&gt; (Jerarquía Estándar del sistema de archivos de Linux). No todas las distribuciones Linux cumplen exactamente el estándar, pero la mayoría se acercan bastante.&lt;/p&gt;
&lt;p&gt;A continuación, vamos a dar un paseo por el sistema de archivos para darnos cuenta qué hace que nuestro sistema Linux funcione. Esto nos dará la oportunidad de practicar nuestras habilidades de navegación. Una de las cosas que descubriremos es que muchos de los archivos interesantes están en texto plano legible. A medida que vayamos avanzando en nuestra visita guiada, prueba lo siguiente:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cd en un directorio dado&lt;/li&gt;
&lt;li&gt;Lista los contenidos del directorio con ls -l&lt;/li&gt;
&lt;li&gt;Si ves un archivo interesante, determina su contenido con file&lt;/li&gt;
&lt;li&gt;Si parece que pudiera ser texto, trata de verlo con less&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A medida que avancemos, no tengas miedo de echar un vistazo. Los usuarios normales tienen terminantemente prohibido &lt;strong&gt;desordenar&lt;/strong&gt; cosas. &lt;em&gt;¡Es trabajo para los administradores de sistema!&lt;/em&gt; Si un comando protesta sobre algo, pasa a otra cosa. Pasa algo de tiempo echando un vistazo. El sistema es nuestro para explorarlo. Recuerda, en Linux, ¡no hay secretos!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;/&lt;/strong&gt; : El directorio raíz. Donde comienza todo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/bin&lt;/strong&gt; : Contiene binarios (programas) que tienen que estar presentes para que el sistema arranque y funcione.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/boot&lt;/strong&gt; : Contiene el kernel de Linux, la imagen del disco de RAM inicial (para controladores necesarios en el momento del arranque), y el cargador de arranque. Archivos interesantes:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;/boot/grub/grub.conf&lt;/strong&gt; o &lt;strong&gt;menu.lst&lt;/strong&gt;, que se utilizan para configurar el cargador de arranque.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/boot/vmlinuz&lt;/strong&gt;, el kernel de Linux.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/dev&lt;/strong&gt; : Este es un directorio especial que contiene los nodos de dispositivo. &lt;strong&gt;“Todo es un archivo”&lt;/strong&gt; también se aplica a los dispositivos. Aquí es donde el kernel mantiene una lista de todos los dispositivos que reconoce.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/etc&lt;/strong&gt; : El directorio /etc contiene todos los archivos de configuración del sistema. También contiene una colección de scripts de shell que inician cada uno de los servicios del sistema durante el arranque. Todo en este directorio debería ser texto legible.
Archivos interesantes: Como todo en /etc es interesante, os dejo algunos de mis favoritos de siempre:
_ &lt;strong&gt;/etc/crontab&lt;/strong&gt;, un archivo que define cuándo se ejecutarán los trabajos automáticos.
_ &lt;strong&gt;/etc/fstab&lt;/strong&gt;, una tabla de los dispositivos de almacenamiento y sus puntos de montaje asociados. * &lt;strong&gt;/etc/passwd&lt;/strong&gt;, una lista de las cuentas de usuario.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/home&lt;/strong&gt; : En configuraciones normales, a cada usuario se le asigna un directorio en /home. Los usuarios normales sólo pueden escribir archivos en sus directorios home. Esta limitación protege el sistema de actividades erróneas de los usuarios.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/lib&lt;/strong&gt; : Contiene archivos de bibliotecas compartidas utilizadas por los programas del núcleo del sistema. Son similares a las DLL de Windows.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/lost+found&lt;/strong&gt; : Cada partición formateada o dispositivo que usa un sistema de archivos de Linux como ext3, tendrá este directorio. Se usa en caso de una recuperación parcial causada por un evento de corrupción del sistema de archivos. A menos que algo realmente malo ocurra a tu sistema, este directorio debería permanecer vacío.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/media&lt;/strong&gt; : En sistemas Linux modernos el directorio /media contendrá los puntos de montaje de los dispositivos extraíbles como unidades USB, CD-ROMs, etc. que se montan automáticamente al introducirlos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/mnt&lt;/strong&gt; : El sistemas Linux antiguos, el directorio /mnt contiene los puntos de montaje de los dispositivos extraíbles que han sido montados manualmente.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/opt&lt;/strong&gt; : El directorio /opt se usa para instalar software “opcional”. Principalmente se usa para contener productos de software comercial que podrían ser instalados en tu sistema.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/proc&lt;/strong&gt; : El directorio /proc es especial. No es un sistema de ficheros real en el sentido de archivos almacenados en tu disco duro. En su lugar, es un sistema de archivos virtual mantenido por el kernel de Linux. Los “archivos” que contienen son como mirillas dentro del propio núcleo. Los archivos son legibles y te darán una descripción de cómo el kernel ve el ordenador.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/root&lt;/strong&gt; : Es el directorio home para la cuenta root.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/sbin&lt;/strong&gt; : Este directorio contiene binarios del &amp;ldquo;sistema&amp;rdquo;. Son programas que realizan tareas vitales del sistema que generalmente están reservadas al superusuario.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/tmp&lt;/strong&gt; : El directorio /tmp está destinado a almacenamiento de archivos temporales creados por varios programas. Algunas configuraciones hacen que este directorio sea vaciado cada vez que el sistema se reinicia.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/usr&lt;/strong&gt; : El árbol del directorio /usr es casi el más grande en un sistema Linux. Contiene todos los programas y archivos de soporte utilizados por los usuarios normales.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/usr/bin&lt;/strong&gt; : Contiene los programas ejecutables instalados en tu distribución Linux. No es raro que este directorio contenga miles de programas.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/usr/lib&lt;/strong&gt; : Las bibliotecas compartidas para los programas en /usr/bin.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/usr/local&lt;/strong&gt; : El árbol /usr/local es donde están instalados los programas que no están incluidos en tu distribución pero están destinados a un uso general. Los programas compilados a partir del código fuente normalmente se instalan en /usr/local/bin. En un sistema Linux recién instalado, este árbol existe, pero estará vacío hasta que el administrador del sistema coloque algo en él.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/usr/sbin&lt;/strong&gt; : Contiene más programas de administración del sistema.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/usr/share&lt;/strong&gt; : Contiene todos los datos compartidos utilizados por los programas en /usr/bin. Esto incluye cosas como archivos de configuración por defecto, iconos, fondos de pantalla, archivos de sonido, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/usr/share/doc&lt;/strong&gt; : La mayoría de los paquetes instalados en el sistema incluirán algún tipo de documentación. En /usr/share/doc, encontraremos archivos de documentación ordenados por paquetes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/var&lt;/strong&gt; : Con la excepción de /tmp y /home, los directorios que hemos visto hasta ahora permanecen relativamente estáticos, o sea, su contenido no cambia. El árbol del directorio /var es donde los datos, que es probable que cambien, son almacenados. Diferentes bases de datos, colas de impresión, correos de usuarios, etc. se encuentran aquí.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/var/log&lt;/strong&gt; : Contiene archivos de registro (log files) de varias actividades del sistema. Son muy importantes y deberían ser monitorizados de vez en cuando. El más útil es /var/log/messages. Ten en cuenta que, por razones de seguridad, en algunos sistemas, tienes que ser superusuario para ver los archivos de registro.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="enlaces-simbólicos"&gt;
Enlaces Simbólicos
&lt;a href="#enlaces-simb%c3%b3licos" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;A medida que inspeccionamos, es probable que veamos un listado de directorios con una entrada como esta:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lrwxrwxrwx 1 root root 11 2007-08-11 07:34
libc.so.6 -&amp;gt; libc-2.6.so
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;¿Ves como la primera letra del listado es “l” y la entrada parece tener dos nombres de archivo? Esto es un tipo especial de archivo llamado enlace simbólico (también conocido como enlace blando o sym-link.) En la mayoría de los sistemas tipo Unix es posible tener un archivo referenciado por múltiples nombres. Aunque el sentido de esto no parezca obvio, es realmente una característica muy útil.&lt;/p&gt;
&lt;p&gt;Imagina este escenario: Un programa requiere el uso de algún tipo de recurso compartido contenido en un archivo llamado “foo”, pero “foo” tiene frecuentes cambios de versión. Sería bueno incluir el número de versión en el nombre del archivo para que el administrador u otras partes interesadas pudieran ver qué versión de “foo” está instalada. Esto presenta un problema. Si cambiamos el nombre del recurso compartido, tenemos que localizar cada programa que pudiera usarlo y cambiarlo para que busque el nuevo nombre del recurso cada vez que se instale una nueva versión del mismo. Esto no suena nada divertido.&lt;/p&gt;
&lt;p&gt;Aquí es donde los enlaces simbólicos nos salvan el día. Digamos que instalamos la versión 2.6 de “foo”, que tiene el nombre de archivo “foo-2.6” y entonces creamos un enlace simbólico llamado simplemente “foo” que apunta a “foo-2.6”. Esto significa que cuando un programa abre el archivo &amp;ldquo;foo&amp;rdquo;, en realidad está abriendo el archivo &amp;ldquo;foo-2.6&amp;rdquo;. Ahora todo el mundo está contento. Los programas que utilizan “foo” pueden encontrarlo y nosotros aún podemos ver qué versión está instalada en realidad. Cuando llegue la hora de actualizar a “foo-2.7”, sólo añadiremos el archivo a nuestro sistema, borraremos el enlace simbólico “foo” y crearemos uno nuevo que apunte a la nueva versión. No sólo soluciona el problema del cambio de versión, también nos permite guardar ambas versiones en nuestra máquina. Imagina que “foo-2.7” tiene un bug (¡Condenados programadores!) y necesitamos recuperar la versión antigua. De nuevo, sólo borramos el enlace simbólico que apunta a la nueva versión y creamos un nuevo enlace simbólico apuntando a la versión antigua.&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="enlaces-duros"&gt;
Enlaces duros
&lt;a href="#enlaces-duros" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Como estamos en el tema de los enlaces, tenemos que mencionar que hay un segundo tipo de enlace llamado enlace duro. Los enlaces duros también permiten a los archivos tener múltiples nombres, pero lo hacen de una forma distinta. Hablaremos más sobre las diferencias entre enlaces simbólicos y duros más adelante.&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="resumiendo"&gt;
Resumiendo
&lt;a href="#resumiendo" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Terminada nuestra visita guiada, hemos aprendido un montón acerca de nuestro sistema. Hemos visto varios archivos y directorios y sus contenidos. Una cosa que deberías haber sacado de esto es lo abierto que es el sistema. En Linux hay muchos archivos importantes que están en texto plano y legible. Al contrario que muchos sistemas propietarios, Linux hace que todo pueda ser examinado y estudiado.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Recorda &lt;strong&gt;apoyarnos&lt;/strong&gt; en nuestras redes para poder seguir adelante con todo lo que implica PatoJAD es un proyecto que poco a poco crece e intenta estar al lado de todos de los usuarios dándoles dia a dia herramientas o funcionalidades. Mostranos tu apoyo con pequeños gestos, desactivando el bloqueador de anuncios, apoyándonos en las redes sociales, donando o compartiendo el contenido, esto solo es posible gracias a cada lector y cada persona que demuestra su agradecimiento&lt;/p&gt;</description></item><item><title>Preparandose para explorar el sistema</title><link>https://patojad.com.ar/post/2020/07/preparandose-para-explorar-el-sistema/</link><pubDate>Fri, 24 Jul 2020 09:38:00 +0000</pubDate><guid>https://patojad.com.ar/post/2020/07/preparandose-para-explorar-el-sistema/</guid><description>&lt;p&gt;Ahora que sabemos cómo movernos por el sistema de archivos, es hora de realizar una visita guiada por nuestro sistema GNU/Linux. Sin embargo, antes de empezar, vamos a aprender algunos comandos más que serán útiles en nuestro viaje:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ls&lt;/strong&gt; – Lista los contenidos de un directorio&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;file&lt;/strong&gt; – Muestra el tipo de archivo&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;less&lt;/strong&gt; – Muestra el contenido del archivo&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="averiguando-el-tipo-de-archivo-con-file"&gt;
Averiguando el tipo de archivo con file
&lt;a href="#averiguando-el-tipo-de-archivo-con-file" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Al explorar el sistema será útil saber qué contienen los archivos. Para hacerlo utilizaremos el comando &lt;em&gt;file&lt;/em&gt; para determinar el tipo de archivo. Como vimos antes, los nombres de archivo en Linux no necesitan reflejar el contenido del archivo. Mientras que un nombre de archivo como “picture.jpg” se espera que contenga una imagen comprimida JPEG, esto no tiene por qué ser así en Linux. Podemos invocar el comando file de la siguiente forma:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;file nombre_del_archivo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cuando se invoca, el comando file mostrará una breve descripción del contenido del archivo. Por ejemplo:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;file lince.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Genera una salida como la siguiente:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lince.jpg: JPEG image data, JFIF standard 1.01
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;div class="flex flex-wrap justify-center"&gt;
&lt;img src="https://i.postimg.cc/fLFKNtNs/Screenshot-20200724-092502.png" alt="" title=""
loading="eager" fetchpriority="high" decoding="async"
class="rounded-xl" /&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Hay muchos tipos de archivos. De hecho, una de las ideas comunes en los sistemas operativos tipo Unix, como es Linux, es que &lt;strong&gt;“todo es un archivo”&lt;/strong&gt;. Mientras que muchos de los archivos en tu sistema son familiares, por ejemplo MP3 y JPEG, hay otros muchos que son un poco menos obvios y algunos que son un poco raros.&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="viendo-el-contenido-de-un-archivo-con-less"&gt;
Viendo el contenido de un archivo con less
&lt;a href="#viendo-el-contenido-de-un-archivo-con-less" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;El comando less es un programa para ver archivos de texto. En nuestro sistema Linux, hay muchos archivos que contienen texto legible por humanos. El programa less proporciona una forma adecuada para examinarlos.&lt;/p&gt;
&lt;p&gt;¿Para qué querríamos examinar archivos de texto? Porque muchos de los archivos que contienen la configuración del sistema (llamados archivos de configuración) están almacenados en este formato, y ser capaces de leerlos nos permite ver cómo funciona el sistema por dentro. Además, muchos de los programas que el sistema utiliza (llamados scripts) están almacenados en este formato. En capítulos posteriores, aprenderemos cómo editar archivos de texto para modificar configuraciones del sistema y escribiremos nuestros propios scripts, pero por ahora sólo veremos su contenido.&lt;/p&gt;
&lt;p&gt;El comando less se usa de la siguiente manera:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;less nombre_del_archivo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Una vez ejecutado, el programa less nos permite desplazarnos arriba y abajo a través de un archivo de texto. Por ejemplo, para examinar el archivo que define todas las cuentas de usuario del sistema, usamos el siguiente comando:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;less /etc/passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;div class="flex flex-wrap justify-center"&gt;
&lt;img src="https://i.postimg.cc/D0XcyvvX/Screenshot-20200724-092653.png" alt="" title=""
loading="lazy" decoding="async"
class="rounded-xl" /&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Una vez que el programa less arranca, podemos ver el contenido del archivo. Si el archivo ocupa más de una página, podemos desplazarnos arriba y abajo. Para salir de less, pulsamos la tecla “q”.&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="menos-es-más-less-is-more"&gt;
Menos es Más (Less is More)
&lt;a href="#menos-es-m%c3%a1s-less-is-more" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;El programa less fue diseñado como un reemplazo mejorado de un programa anterior de Unix llamado more. El nombre &amp;ldquo;less&amp;rdquo; viene de un juego de palabras “menos es mas – less is more” - un lema de los arquitectos y diseñadores modernistas.&lt;/p&gt;
&lt;p&gt;less entra en la clase de programas llamados “paginadores”, que permiten ver fácilmente documentos de texto largos en forma de páginas. Mientras que el programa more sólo permitía avanzar páginas, el programa less permite avanzar y retroceder por las páginas y cuenta también con otras características.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Recorda &lt;strong&gt;apoyarnos&lt;/strong&gt; en nuestras redes para poder seguir adelante con todo lo que implica PatoJAD es un proyecto que poco a poco crece e intenta estar al lado de todos de los usuarios dándoles dia a dia herramientas o funcionalidades. Mostranos tu apoyo con pequeños gestos, desactivando el bloqueador de anuncios, apoyándonos en las redes sociales, donando o compartiendo el contenido, esto solo es posible gracias a cada lector y cada persona que demuestra su agradecimiento&lt;/p&gt;</description></item><item><title>Más diversión con ls</title><link>https://patojad.com.ar/post/2020/07/m%C3%A1s-diversi%C3%B3n-con-ls/</link><pubDate>Wed, 15 Jul 2020 09:17:00 +0000</pubDate><guid>https://patojad.com.ar/post/2020/07/m%C3%A1s-diversi%C3%B3n-con-ls/</guid><description>&lt;p&gt;El comando ls es &lt;em&gt;probablemente el más usado&lt;/em&gt;, y por una buena razón. Con él, podemos ver los contenidos de un directorio y determinar varios atributos importantes de los archivos y directorios. Como hemos visto, podemos usar simplemente ls para ver una lista de los archivos y subdirectorios contenidos en el directorio de trabajo actual:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-zsh" data-lang="zsh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ls
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;obteniendo una salida&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-zsh" data-lang="zsh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Desktop Documents Music Pictures Public Templates Videos
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Además del directorio de trabajo actual, podemos especificar el directorio a listar, de esta forma:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-zsh" data-lang="zsh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ls /usr
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;obteniendo una salida&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-zsh" data-lang="zsh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;bin games kerberos libexec sbin src
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;etc include lib &lt;span class="nb"&gt;local&lt;/span&gt; share tmp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;O incluso especificar múltiples directorios. En este ejemplo listaremos el directorio home del usuario (simbolizado por el carácter “~”) y el directorio /usr:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-zsh" data-lang="zsh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ls ~ /usr
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;obteniendo una salida&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-zsh" data-lang="zsh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;/home/pato:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Desktop Documents Music Pictures Public Templates Videos
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;/usr:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;bin games kerberos libexec sbin src
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;etc include lib &lt;span class="nb"&gt;local&lt;/span&gt; share tmp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;También podemos cambiar el formato de la salida para que nos muestre más detalles:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-zsh" data-lang="zsh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ls -l
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;con una salida&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-zsh" data-lang="zsh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;total &lt;span class="m"&gt;56&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;drwxrwxr-x &lt;span class="m"&gt;2&lt;/span&gt; me me &lt;span class="m"&gt;4096&lt;/span&gt; 2007-10-26 17:20 Desktop
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;drwxrwxr-x &lt;span class="m"&gt;2&lt;/span&gt; me me &lt;span class="m"&gt;4096&lt;/span&gt; 2007-10-26 17:20 Documents
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;drwxrwxr-x &lt;span class="m"&gt;2&lt;/span&gt; me me &lt;span class="m"&gt;4096&lt;/span&gt; 2007-10-26 17:20 Music
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;drwxrwxr-x &lt;span class="m"&gt;2&lt;/span&gt; me me &lt;span class="m"&gt;4096&lt;/span&gt; 2007-10-26 17:20 Pictures
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;drwxrwxr-x &lt;span class="m"&gt;2&lt;/span&gt; me me &lt;span class="m"&gt;4096&lt;/span&gt; 2007-10-26 17:20 Public
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;drwxrwxr-x &lt;span class="m"&gt;2&lt;/span&gt; me me &lt;span class="m"&gt;4096&lt;/span&gt; 2007-10-26 17:20 Templates
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;drwxrwxr-x &lt;span class="m"&gt;2&lt;/span&gt; me me &lt;span class="m"&gt;4096&lt;/span&gt; 2007-10-26 17:20 Videos
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Añadiendo “-l” al comando, cambiamos la salida al formato largo.&lt;/p&gt;
&lt;p&gt;
&lt;div class="flex flex-wrap justify-center"&gt;
&lt;img src="https://i.postimg.cc/Kz0rYX84/Screenshot-20200715-084652.png" alt="" title=""
loading="eager" fetchpriority="high" decoding="async"
class="rounded-xl" /&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="opciones-y-argumentos"&gt;
Opciones y argumentos
&lt;a href="#opciones-y-argumentos" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Esto nos ofrece un aspecto muy importante sobre cómo funcionan la mayoría de los comandos. A los comandos, a menudo, le siguen una o más opciones que modifican su comportamiento, y adicionalmente, uno o más argumentos, los elementos sobre los que el comando actúa. Así que la mayoría de los comandos se muestran así:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-zsh" data-lang="zsh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;comando -opciones argumentos
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;La mayoría de los comandos usan opciones que consisten en un sólo carácter precedido por un guión, por ejemplo, “-l”, pero muchos comandos, incluidos los del Proyecto GNU, también soportan opciones largas, consistentes en una palabra precedida por dos guiones. Además, muchos comandos permiten múltiples opciones cortas enlazadas. En este ejemplo, al comando ls se le han dado dos opciones, la opción “l” para mostrar la salida en formato largo, y la opción “t” para ordenar el resultado por la fecha de modificación de los archivos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-zsh" data-lang="zsh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ls -lt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Añadiremos la opción larga “&amp;ndash;reverse” para invertir el orden de la lista:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-zsh" data-lang="zsh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ls -lt --reverse
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Fíjate que las opciones de los comandos, como los nombres de archivo en Linux, distinguen entre mayúsculas y minúsculas.&lt;/p&gt;
&lt;p&gt;
&lt;div class="flex flex-wrap justify-center"&gt;
&lt;img src="https://i.postimg.cc/4NqPtTb9/Screenshot-20200715-084749.png" alt="" title=""
loading="lazy" decoding="async"
class="rounded-xl" /&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;El comando ls tiene un gran número de posibles opciones. Las más comunes están listadas a continuación.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-a &amp;ndash;all&lt;/strong&gt; Lista todos los archivos, incluso aquellos cuyo nombre empieza con un punto, que normalmente no se listan (es decir, ocultos).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-A &amp;ndash;almost-all&lt;/strong&gt; Como la opción -a anterior, salvo que no lista . (el directorio actual) y .. (el directorio padre).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-d &amp;ndash;directory&lt;/strong&gt; Por lo general, si especificamos un directorio, ls listará los contenidos del directorio y no el directorio en sí. Usa esta opción junto con la opción -l para ver detalles del directorio en lugar de su contenido.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-F &amp;ndash;classify&lt;/strong&gt; Esta opción añadirá un carácter indicador al final de cada nombre listado. Por ejemplo, una “/” es que el nombre es un directorio.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-h &amp;ndash;human-readable&lt;/strong&gt; En los listados en formato largo, muestra el tamaño de los archivos en un formato comprensible, en lugar de en bytes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-l&lt;/strong&gt; Muestra los resultados en formato largo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-r &amp;ndash;reverse&lt;/strong&gt; Muestra los resultados en orden inverso. Normalmente, ls muestra los resultados en orden alfabético ascendente.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-S&lt;/strong&gt; Ordena los resultados por tamaño.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-t&lt;/strong&gt; Ordena por la fecha de modificación.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="un-vistazo-más-profundo-al-formato-largo"&gt;
Un vistazo más profundo al formato largo
&lt;a href="#un-vistazo-m%c3%a1s-profundo-al-formato-largo" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Como vimos antes, la opción “-l” hace que ls muestre sus resultados en formato largo. Este formato contiene gran cantidad de información útil. Aquí está el directorio Examples de un sistema Ubuntu:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-zsh" data-lang="zsh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;3576296&lt;/span&gt; 2007-04-03 11:05 Experience patojad.ogg
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;1186219&lt;/span&gt; 2007-04-03 11:05 patojad-leaflet.png
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;47584&lt;/span&gt; 2007-04-03 11:05 logo-LynxOS.png
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;44355&lt;/span&gt; 2007-04-03 11:05 logo-PatoJAD.png
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;34391&lt;/span&gt; 2007-04-03 11:05 logo-Antix.png
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;32059&lt;/span&gt; 2007-04-03 11:05 oo-cd-cover.odf
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;159744&lt;/span&gt; 2007-04-03 11:05 oo-derivatives.doc
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;27837&lt;/span&gt; 2007-04-03 11:05 oo-maxwell.odt
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;98816&lt;/span&gt; 2007-04-03 11:05 oo-trig.xls
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;453764&lt;/span&gt; 2007-04-03 11:05 oo-welcome.odt
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;358374&lt;/span&gt; 2007-04-03 11:05 patojad Sax.ogg
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Veamos los diferentes campos de uno de los archivos y examinemos su significado:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-rw-r&amp;ndash;r&amp;ndash;&lt;/strong&gt; Permisos de acceso al archivo. El primer carácter indica el tipo de archivo. Entre los diferentes tipos, un guión al principio significa un archivo normal, mientras que una “d” indica un directorio. Los siguientes tres caracteres son los permisos de acceso para el propietario del archivo, los tres siguientes los de los miembros del grupo del archivo, y lo tres últimos los del resto de usuarios. El significado completo de esto lo trataremos en el Capítulo 9 – Permisos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt; Número de enlaces fuertes del archivo. Veremos el tema de los enlaces más adelante.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;root&lt;/strong&gt; El nombre del propietario del archivo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;root&lt;/strong&gt; El nombre del grupo propietario del archivo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;32059&lt;/strong&gt; Tamaño del archivo en bytes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2007-04-03 11:05&lt;/strong&gt; Fecha y hora de la última modificación del archivo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;oo-cd-cover.odf&lt;/strong&gt; Nombre del archivo.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Moviendose en la Terminal</title><link>https://patojad.com.ar/post/2020/07/moviendose-en-la-terminal/</link><pubDate>Wed, 08 Jul 2020 09:17:00 +0000</pubDate><guid>https://patojad.com.ar/post/2020/07/moviendose-en-la-terminal/</guid><description>&lt;p&gt;En esta oportunidad queremos ver un poco como es la navegación mediante la terminal, y como siempre digo, esto lo hacemos a modo de amigarnos con la terminal. No siempre es necesario hacerlo de tal manera pero es útil y rápido en muchas ocasiones&amp;hellip;&lt;/p&gt;
&lt;p&gt;Lo primero que necesitamos aprender es &lt;strong&gt;cómo navegar&lt;/strong&gt; por el sistema de archivos en nuestro sistema GNU/Linux. En este inicio presentaremos los siguientes comandos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;pwd&lt;/strong&gt; – Muestra el nombre del directorio de trabajo actual&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cd&lt;/strong&gt; – Cambia de directorio&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ls&lt;/strong&gt; – Muestra el contenido del directorio&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="el-directorio-de-trabajo-actual"&gt;
El directorio de trabajo actual
&lt;a href="#el-directorio-de-trabajo-actual" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;La mayoría de nosotros, probablemente, &lt;strong&gt;estamos familiarizados con un gestor de archivos gráfico&lt;/strong&gt; que representa el árbol del sistema de directorios. Fíjate que el árbol, normalmente, aparece colgando boca abajo, o sea, con la raíz arriba y las ramas hacia abajo.&lt;/p&gt;
&lt;p&gt;
&lt;div class="flex flex-wrap justify-center"&gt;
&lt;img src="http://multimedia.uoc.edu/blogs/sqsw/files/2013/01/sfjerar.gif" alt="" title=""
loading="eager" fetchpriority="high" decoding="async"
class="rounded-xl" /&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Sin embargo, la línea de comandos no tiene imágenes (o al menos no nativamente), así que para navegar por el árbol del sistema de ficheros tenemos que pensar de una forma &lt;strong&gt;un poco diferente&lt;/strong&gt; a lo que venimos &lt;em&gt;acostumbrados&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Imagina que el sistema de ficheros es como un laberinto con forma de árbol boca abajo y que podemos estar dentro de él. En un momento dado, estamos dentro de un directorio en concreto y podemos ver los archivos contenidos en él, y la ruta hacia el directorio que está sobre nosotros (llamado directorio padre) y los subdirectorios debajo de nosotros. Este directorio, en el cual estamos, se llama directorio de trabajo actual. Para mostrar el directorio de trabajo actual, utilizamos el comando pwd (print working directory):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obteniendo una salida similar a esta&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/home/pato
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;div class="flex flex-wrap justify-center"&gt;
&lt;img src="https://i.postimg.cc/6pxrpC3d/Screenshot-20200708-090455.png" alt="" title=""
loading="lazy" decoding="async"
class="rounded-xl" /&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;La primera vez que accedemos al sistema nuestro directorio de trabajo actual es nuestro directorio home (~). Cada cuenta de usuario tiene su propio directorio home y es el &lt;strong&gt;único lugar donde un usuario sin privilegios puede escribir archivos&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="listando-los-contenidos-de-un-directorio"&gt;
Listando los contenidos de un directorio
&lt;a href="#listando-los-contenidos-de-un-directorio" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Para listar los archivos y directorios en el directorio de trabajo actual, usamos el comando ls.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obteniendo una salida similar a esta&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Desktop Documents Music Pictures Public Templates Videos
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;div class="flex flex-wrap justify-center"&gt;
&lt;img src="https://i.postimg.cc/J4ZTxrH5/Screenshot-20200708-090638.png" alt="" title=""
loading="lazy" decoding="async"
class="rounded-xl" /&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;En realidad, podemos usar el comando ls para listar el contenido de cualquier directorio, no solo el directorio de trabajo actual, y hay muchas otras cosas curiosas que puede hacer también…&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="cambiando-el-directorio-de-trabajo-actual"&gt;
Cambiando el directorio de trabajo actual
&lt;a href="#cambiando-el-directorio-de-trabajo-actual" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Para cambiar el directorio de trabajo actual utilizamos el comando cd. Para hacer esto, escribe cd seguido de la ruta del directorio de trabajo que queramos. Una ruta es el camino de tomamos a través de las ramas del árbol para llegar al directorio que queremos. Las rutas pueden ser &lt;strong&gt;especificadas de dos formas&lt;/strong&gt;; como rutas &lt;strong&gt;absolutas&lt;/strong&gt; o como rutas &lt;strong&gt;relativas&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="rutas-absolutas"&gt;
Rutas Absolutas
&lt;a href="#rutas-absolutas" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Una ruta absoluta comienza con el &lt;strong&gt;directorio raíz&lt;/strong&gt; y sigue &lt;em&gt;rama tras rama&lt;/em&gt; hasta que la ruta al directorio o archivo que queremos está completa. Por ejemplo, hay un directorio en nuestro sistema en el que la mayoría de los programas de sistema están instalados. La ruta de dicho directorio es /usr/bin. Esto significa que en el directorio raíz (representado por la barra inclinada en la ruta) hay un directorio llamado “usr” que contiene un directorio llamado “bin”.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /usr/bin
pwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obtendremos una salida como&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/bin
ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y esto listará muchísimos archivos&lt;/p&gt;
&lt;p&gt;
&lt;div class="flex flex-wrap justify-center"&gt;
&lt;img src="https://i.postimg.cc/5ywwBtKH/Screenshot-20200708-090822.png" alt="" title=""
loading="lazy" decoding="async"
class="rounded-xl" /&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Ahora podemos ver que &lt;strong&gt;hemos cambiado el directorio&lt;/strong&gt; de trabajo a /usr/bin y que está lleno de archivos. ¿Ves cómo ha cambiado el prompt del shell? Por defecto, normalmente está configurado para mostrar automáticamente el nombre del directorio de trabajo.&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="rutas-relativas"&gt;
Rutas Relativas
&lt;a href="#rutas-relativas" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Mientras que una ruta absoluta empieza desde el directorio raíz y sigue hasta su destino, &lt;strong&gt;una ruta relativa comienza en el directorio de trabajo&lt;/strong&gt;. Para hacer esto, utiliza un par de símbolos especiales que representan posiciones relativas en el árbol del sistema de archivos. Estos símbolos son “.” &lt;em&gt;(punto)&lt;/em&gt; y “..” &lt;em&gt;(punto punto)&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;El símbolo “.” se refiere al directorio de trabajo y el símbolo “..” se refiere al directorio padre del directorio de trabajo. Veamos cómo funciona. Ahora le diremos que queremos cambiar el directorio de trabajo al padre de /usr/bin que es /usr. Podríamos hacerlo de dos formas diferentes. Tanto con una ruta absoluta:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /usr
pwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obteniendo una salida como esta&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como, con una ruta relativa:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd ..
pwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obteniendo una salida como esta&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dos métodos diferentes con idénticos resultados. ¿Cuál usamos? ¡El que requiera teclear menos!&lt;/p&gt;
&lt;p&gt;
&lt;div class="flex flex-wrap justify-center"&gt;
&lt;img src="https://i.postimg.cc/HszMdRqC/Screenshot-20200708-091020.png" alt="" title=""
loading="lazy" decoding="async"
class="rounded-xl" /&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Ahora, hay algo importante que se debe señalar aquí. En la mayoría de los casos, puedes omitir el “./”. Está implícito. Escribir:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;hace lo mismo. En general, si no especificas una ruta a algo, se asumirá el directorio de trabajo.&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="algunos-atajos-útiles"&gt;
Algunos atajos útiles
&lt;a href="#algunos-atajos-%c3%batiles" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Veamos algunas formas útiles para cambiar rápidamente el directorio de trabajo actual.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cambia el directorio de trabajo a tu directorio home.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cambia el directorio de trabajo al anterior directorio de trabajo.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd ~nombre_de_usuario
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cambia el directorio de trabajo al directorio home de nombre_de_usuario. Por ejemplo, cd ~pato cambiará el directorio al directorio home del usuario “pato”.&lt;/p&gt;
&lt;p&gt;
&lt;div class="flex flex-wrap justify-center"&gt;
&lt;img src="https://i.postimg.cc/sxV2LDDG/Screenshot-20200708-091153.png" alt="" title=""
loading="lazy" decoding="async"
class="rounded-xl" /&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="resumiendo"&gt;
Resumiendo
&lt;a href="#resumiendo" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;En este capítulo hemos visto como el shell trata la estructura de directorios del sistema. Hemos aprendido sobre las rutas absolutas y relativas y los comandos básicos que se usan para moverse por dicha estructura. En el próximo capítulo utilizaremos este conocimiento para darnos una vuelta por un sistema Linux moderno.&lt;/p&gt;
&lt;p&gt;Fuente: &lt;strong&gt;&amp;ldquo;The Linux Command Line - Second Internet Edition&amp;rdquo;&lt;/strong&gt; de &lt;em&gt;William E. Shotts, Jr.&lt;/em&gt; - (es) &lt;strong&gt;Adriano Sánchez&lt;/strong&gt;&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="tambien-leer"&gt;
Tambien Leer
&lt;a href="#tambien-leer" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://patojad.com.ar/posts/2020/07/por-qu%c3%a9-usar-la-l%c3%adnea-de-comandos/" class="text-fuchsia-700 hover:text-fuchsia-800 dark:text-fuchsia-700 dark:hover:text-fuchsia-800 font-semibold"&gt;
&lt;i class="fas fa-link"&gt;&lt;/i&gt;&amp;nbsp;
¿Por qué usar la línea de comandos?
&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>