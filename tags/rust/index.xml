<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on PatoJAD | Pasion por la Tecnologia</title><link>https://patojad.com.ar/tags/rust/</link><description>Recent content in Rust on PatoJAD | Pasion por la Tecnologia</description><generator>Hugo -- gohugo.io</generator><language>es-AR</language><lastBuildDate>Tue, 03 Feb 2026 08:31:00 +0000</lastBuildDate><atom:link href="https://patojad.com.ar/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Terminal Pro 2026: Deja de usar comandos de los años 70</title><link>https://patojad.com.ar/post/2026/02/terminal-pro-2026-deja-de-usar-comandos-de-los-a%C3%B1os-70/</link><pubDate>Tue, 03 Feb 2026 08:31:00 +0000</pubDate><guid>https://patojad.com.ar/post/2026/02/terminal-pro-2026-deja-de-usar-comandos-de-los-a%C3%B1os-70/</guid><description>&lt;p&gt;Linux es famoso por su estabilidad, pero eso no significa que debas seguir usando las mismas herramientas que se inventaron cuando no existía internet. En 2026, hay una nueva generación de herramientas escritas en Rust y Go que son más rápidas, tienen mejores colores y, sobre todo, te hacen más productivo.&lt;/p&gt;
&lt;p&gt;Aquí tienes los reemplazos directos que todo dev debería instalar hoy mismo:&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="1-eza-el-reemplazo-de-ls"&gt;
1. &lt;code&gt;eza&lt;/code&gt; (El reemplazo de &lt;code&gt;ls&lt;/code&gt;)
&lt;a href="#1-eza-el-reemplazo-de-ls" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;¿Sigues usando &lt;code&gt;ls -la&lt;/code&gt;? &lt;code&gt;eza&lt;/code&gt; (el sucesor de &lt;code&gt;exa&lt;/code&gt;) te da colores por tipo de archivo, iconos, integración con Git y una vista de árbol integrada.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;eza --long --header --git --icons
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="2-bat-el-reemplazo-de-cat"&gt;
2. &lt;code&gt;bat&lt;/code&gt; (El reemplazo de &lt;code&gt;cat&lt;/code&gt;)
&lt;a href="#2-bat-el-reemplazo-de-cat" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; es genial para ver un archivo rápido, pero no tiene resaltado de sintaxis. &lt;code&gt;bat&lt;/code&gt; es un clon de &lt;code&gt;cat&lt;/code&gt; con esteroides: añade numeración de líneas, integración con Git (muestra qué líneas cambiaste) y syntax highlighting para casi cualquier lenguaje de programación.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;bat archivo.ts
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="3-fd-el-reemplazo-de-find"&gt;
3. &lt;code&gt;fd&lt;/code&gt; (El reemplazo de &lt;code&gt;find&lt;/code&gt;)
&lt;a href="#3-fd-el-reemplazo-de-find" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;find&lt;/code&gt; tiene una sintaxis horrible que nadie recuerda. &lt;code&gt;fd&lt;/code&gt; es 10 veces más rápido y su sintaxis es intuitiva. Además, ignora por defecto las carpetas .git y node_modules. ¡Oro puro!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;fd &lt;span class="s2"&gt;&amp;#34;patron_de_busqueda&amp;#34;&lt;/span&gt; ./ruta/de/busqueda
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="4-fzf-el-buscador-borroso"&gt;
4. &lt;code&gt;fzf&lt;/code&gt; (El buscador borroso)
&lt;a href="#4-fzf-el-buscador-borroso" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Si no usas &lt;code&gt;fzf&lt;/code&gt;, estás perdiendo el tiempo. Te permite buscar entre tus archivos o tu historial de comandos de forma interactiva mientras escribes. Es, probablemente, la herramienta que más te va a cambiar la vida en la terminal.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;history&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; fzf
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="4-btop-el-reemplazo-de-top"&gt;
4. &lt;code&gt;btop&lt;/code&gt; (El reemplazo de &lt;code&gt;top&lt;/code&gt;)
&lt;a href="#4-btop-el-reemplazo-de-top" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;top&lt;/code&gt; es funcional, pero feo y difícil de usar. &lt;code&gt;btop&lt;/code&gt; tiene una interfaz mucho más amigable, con colores, barras de uso de CPU/RAM y la capacidad de matar procesos con solo presionar una tecla.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;btop
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>uUtils: La Alternativa Moderna a GNU Coreutils en 2025</title><link>https://patojad.com.ar/post/2025/03/uutils-la-alternativa-moderna-a-gnu-coreutils-en-2025/</link><pubDate>Thu, 27 Mar 2025 09:47:00 +0000</pubDate><guid>https://patojad.com.ar/post/2025/03/uutils-la-alternativa-moderna-a-gnu-coreutils-en-2025/</guid><description>&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="qué-es-uutils"&gt;
Qué es uUtils?
&lt;a href="#qu%c3%a9-es-uutils" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;uUtils es un proyecto de código abierto que busca reimplementar las herramientas básicas de línea de comandos (como ls, cp, grep, etc.) tradicionalmente proporcionadas por GNU Coreutils, pero con un enfoque moderno:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Escrito en Rust (en lugar de C, como GNU Coreutils).&lt;/li&gt;
&lt;li&gt;Diseñado para ser más seguro, rápido y portable (funciona en Linux, Windows y macOS).&lt;/li&gt;
&lt;li&gt;Mantiene compatibilidad con los comandos clásicos, pero con mejoras internas.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En 2025, uUtils ha ganado popularidad entre desarrolladores y entusiastas de la terminal que buscan alternativas más eficientes y mantenibles.&lt;/p&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="uutils-vs-gnu-coreutils-cuál-es-la-diferencia"&gt;
uUtils vs GNU Coreutils: ¿Cuál es la diferencia?
&lt;a href="#uutils-vs-gnu-coreutils-cu%c3%a1l-es-la-diferencia" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Característica&lt;/th&gt;
&lt;th&gt;uUtils&lt;/th&gt;
&lt;th&gt;GNU Coreutils&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Lenguaje&lt;/td&gt;
&lt;td&gt;Rust (memoria segura por diseño)&lt;/td&gt;
&lt;td&gt;C (mayor riesgo de vulnerabilidades)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Portabilidad&lt;/td&gt;
&lt;td&gt;Soporte nativo para Windows/Linux/macOS&lt;/td&gt;
&lt;td&gt;Principalmente Linux/Unix&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Rendimiento&lt;/td&gt;
&lt;td&gt;Optimizado para paralelismo&lt;/td&gt;
&lt;td&gt;Depende de implementaciones antiguas&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mantenimiento&lt;/td&gt;
&lt;td&gt;Comunidad activa (2025)&lt;/td&gt;
&lt;td&gt;Desarrollo más lento (legacy code)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compatibilidad&lt;/td&gt;
&lt;td&gt;Alto, pero con diferencias menores&lt;/td&gt;
&lt;td&gt;Estándar tradicional&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="por-qué-no-usar-gnu-coreutils-directamente"&gt;
¿Por qué no usar GNU Coreutils directamente?
&lt;a href="#por-qu%c3%a9-no-usar-gnu-coreutils-directamente" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Aunque GNU Coreutils es la suite clásica y ampliamente adoptada, uUtils ofrece:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Menos errores de memoria (gracias a Rust).&lt;/li&gt;
&lt;li&gt;Mejor soporte multiplataforma (ideal para desarrolladores que trabajan en distintos SO).&lt;/li&gt;
&lt;li&gt;Comandos más rápidos en ciertos casos (ej: procesamiento paralelo en grep).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="ventajas-y-desventajas-de-uutils"&gt;
Ventajas y Desventajas de uUtils
&lt;a href="#ventajas-y-desventajas-de-uutils" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;h3 class="text-gray-500 text-3xl my-6" id="-ventajas"&gt;
✅ Ventajas
&lt;a href="#-ventajas" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Seguridad mejorada:&lt;/strong&gt; Rust evita vulnerabilidades comunes como buffer overflows.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fácil instalación:&lt;/strong&gt; Disponible en gestores de paquetes (brew, cargo, apt).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Innovación constante:&lt;/strong&gt; Comandos con opciones modernas (ej: mejor manejo de Unicode).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Comunidad activa:&lt;/strong&gt; Más contribuciones en 2025 que GNU Coreutils.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class="text-gray-500 text-3xl my-6" id="-desventajas"&gt;
❌ Desventajas
&lt;a href="#-desventajas" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Diferencias sutiles:&lt;/strong&gt; Algunos flags o comportamientos no son idénticos a GNU.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Menor adopción en empresas:&lt;/strong&gt; GNU sigue siendo el estándar en sistemas legacy.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Documentación en crecimiento:&lt;/strong&gt; Algunas funciones avanzadas están menos documentadas.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="qué-cambios-trae-uutils-para-los-usuarios"&gt;
¿Qué cambios trae uUtils para los usuarios?
&lt;a href="#qu%c3%a9-cambios-trae-uutils-para-los-usuarios" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;h3 class="text-gray-500 text-3xl my-6" id="para-usuarios-casuales"&gt;
Para usuarios casuales:
&lt;a href="#para-usuarios-casuales" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Experiencia similar a GNU Coreutils, pero con menos errores críticos.&lt;/li&gt;
&lt;li&gt;Soporte mejorado en Windows (ej: uutils-ls funciona igual que en Linux).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class="text-gray-500 text-3xl my-6" id="para-desarrolladores"&gt;
Para desarrolladores:
&lt;a href="#para-desarrolladores" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Integración sencilla en entornos CI/CD gracias a su portabilidad.&lt;/li&gt;
&lt;li&gt;Posibilidad de extender funcionalidades (Rust es más modular que C).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class="text-fuchsia-700 text-3xl my-6" id="son-necesarias-nuevas-herramientas-en-2025"&gt;
¿Son necesarias nuevas herramientas en 2025?
&lt;a href="#son-necesarias-nuevas-herramientas-en-2025" class="text-gray-500"&gt;#&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;La respuesta depende del uso:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Si buscas estabilidad y compatibilidad absoluta, GNU Coreutils sigue siendo la opción.&lt;/li&gt;
&lt;li&gt;Si priorizas seguridad, rendimiento y futuro, uUtils es una apuesta sólida.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En un mundo donde la ciberseguridad y la eficiencia son claves, proyectos como uUtils demuestran que incluso las herramientas más antiguas pueden renovarse.&lt;/p&gt;</description></item></channel></rss>